---
title: "Знакомимся с Fabric.js - Часть 2"
layout: post
categories: javascript
tags: [javascript, canvas, fabric]
share: true
---

Вторая часть [официальной документации по Fabric][2]. Речь идет об анимации объектов на Canvas, применении стандартных фильтров к изображениям или создании пользовательских фильтров.

Вычитал и поправил некоторые орфографические ошибки. Продолжает радовать факт, как автор детально и внятно описывает работу каждой строки кода в сниппетах.

***

Это вторая часть серии статей об открытой Javascript Canvas библиотеке Fabric.js, которую мы используем на printio.ru для редактора дизайнов.

В [первой части этой серии][1] мы ознакомились с самыми базовыми аспектами canvas библиотеки Fabric.js. Мы узнали, чем может быть полезна Fabric, рассмотрели ее **объектную модель** и **иерархию объектов**; увидели, что существуют как **простые** фигуры (прямоугольник, треугольник, круг), так и **сложные** (SVG). Научились выполнять простые **операции** над этими объектами.

Ну вот, разобрались с азами, давайте приступать к более интересным вещам!

## Анимация

Любая уважающая себя canvas-библиотека в наше время включает в себя средства работы с **анимацией**. Fabric — не исключение. Ведь мы имеем мощную **объектную модель** и гибкие **графические возможности**. Было бы грех не уметь это приводить в **движение**.

Вы наверное помните, как менять атрибут у объекта. Просто вызываем метод `set`, передавая соответствующее значение:

{% highlight javascript %}
rect.set('angle', 45);
{% endhighlight %}

Анимировать объект можно по такому же принципу и с такой же легкостью. Каждый объект в Fabric имеет метод `animate` (наследуя от `fabric.Object`) который ... анимирует этот объект:

{% highlight javascript %}
rect.animate( 'angle', 45, {
  onChange: canvas.renderAll.bind(canvas)
});
{% endhighlight %}

**Первый аргумент** - это атрибут, который хотим менять. **Второй аргумент** — финальное значение этого атрибута.

Например, если прямоугольник находится под углом `-15°` и мы указываем `45°`, то угол постепенно изменится с `-15°` до `45°`.

Ну, а **последний аргумент** — опциональный объект для более **детальных** настроек (длительность, вызовы, easing и т. д. )

`animate` кстати имеет очень полезную функциональность — поддержку относительных значений. Например, если нужно подвинуть объект на `100px` вправо, то сделать это очень просто:

{% highlight javascript %}
rect.animate('left', '+=100', { onChange: canvas.renderAll.bind(canvas) });
{% endhighlight %}

По такому же принципу, для поворота объекта на 5 градусов против часовой стрелки:

{% highlight javascript %}
rect.animate('angle', '-=5', { onChange: canvas.renderAll.bind(canvas) });
{% endhighlight %}

Вы наверняка заметили, что мы постоянно указываем вызов `onChange`. Разве 3-й аргумент не опциональный? Да, именно так.

Дело в том, что как раз это вызывание `canvas.renderAll` на каждый кадр анимации позволяет видеть саму анимацию!

Mетод `animate` всего лишь изменяет значение атрибута в течении указанного времени и по определенному алгоритму (`easing`).

`rect.animate('angle', 45)` изменяет значение угла, при этом **не перерисовывая** экран после каждого изменения. А перерисовка экрана нужна для того, чтобы увидеть анимацию.

Ну, а почему же `animate` не перерисовывает экран автоматически? Из-за производительности. Ведь на холсте могут находиться сотни или даже тысячи объектов. 

Было бы довольно ужасно, если каждый из объектов перерисовывал экран при изменении. В таком случае лучше использовать, например, `requestAnimationFrame` для **постоянной отрисовки холста**, не вызывая `renderAll` для каждого объекта.

Однако, в большинстве случаев вы скорее всего будете использовать `canvas.renderAll` как `onChange`-вызов.

Возвращаясь к опциям для анимации - что же именно мы можем менять?

* `from:` - позволяет менять начальное значение атрибута для анимации (если не хотим использовать текущее)
* `duration:` - длительность анимации; по умолчанию - 500 ms
* `onComplete:` - функция для вызова в конце анимации (callback)
* `easing:` - функция easing (смягчение)

Все эти опции более менее очевидны, кроме наверное `easing`. Давайте посмотрим поближе.

По умолчанию, `animate` используют `easeInSine`-функцию для смягчения анимации. Если такой вариант не подходит, в Fabric имеется большой набор популярных easing-функций (доступных через объект `fabric.util.ease`).

Например, вот так можно подвинуть объект вправо, при этом "отпружинивая"" в конце:

{% highlight javascript %}
rect.animate('left', 500, {
  onChange: canvas.renderAll.bind(canvas),
  duration: 1000,
  easing: fabric.util.ease.easeOutBounce
});
{% endhighlight %}

Заметьте, что мы используем `fabric.util.ease.easeOutBounce` как опцию смягчения. Есть и другие популярные функции — `easeInCubic`, `easeOutCubic`, `easeInElastic`, `easeOutElastic`, `easeInBounce`, `easeOutExpo` и т. д.

Вот в принципе и все, что нужно знать о анимации. Теперь можно с легкостью делать интересные вещи — менять угол объекта, чтобы сделать его **вращающимся**; анимировать `left/top` чтобы его **двигать**; анимировать `width/height` для **увеличения/уменьшения**; анимировать `opacity` для **появления/исчезания** и т. д.

## Фильтры изображений

В первой части этой серии мы узнали, как работать с изображениями в Fabric. Как вы наверное помните, для этого используется `fabric.Image`-конструктор, передавая в него `<img>`-элемент.

Также есть метод `fabric.Image.fromURL`, с помощью которого можно создать объект прямо из строки URL. И конечно же эти `fabric.Image`-объекты можно кинуть на холст, где они отобразятся как и все остальное.

Работать с изображениями прикольно, а с **фильтрами изображений** — еще веселей! Fabric уже имеет несколько фильтров, а также позволяет легко определять свои. 

Некоторые фильтры из Fabric вам наверное знакомы — удаление белого фона, перевод в черно-белый, негатив или яркость. А некоторые менее популярны — градиентная прозрачность, сепия, шум.

Так как же применить фильтр к изображению? Каждый `fabric.Image`-объект имеет `filters`-атрибут, который просто является **массивом фильтров**. Каждый элемент в этом массиве — или один из существующих в Fabric или собственный фильтр.

Ну вот, к примеру, сделаем картинку **черно-белой**:

{% highlight javascript %}
fabric.Image.fromURL( 'pug.jpg', function ( img ) {
  
  // добавляем фильтр
  img.filters.push( new fabric.Image.filters.Grayscale() );
  
  // применяем фильтры и перерисовываем canvas после применения
  img.applyFilters( canvas.renderAll.bind( canvas ) );
  
  // добавляем изображения на холст
  canvas.add( img );

});
{% endhighlight %}

![Fabric Image]({{site.url}}/images/uploads/2016/06/fabricjs-part-2-01.png "Fabric Image")

А вот так можно сделать **сепию**:

{% highlight javascript %}
fabric.Image.fromURL( 'pug.jpg', function ( img ) {
  
  img.filters.push( new fabric.Image.filters.Sepia() );
  
  img.applyFilters( canvas.renderAll.bind( canvas ) );
  
  canvas.add( img );

});
{% endhighlight %}

![Fabric Image]({{site.url}}/images/uploads/2016/06/fabricjs-part-2-02.png "Fabric Image")

С атрибутом `filters` можно делать все тоже что и с обычным массивом — удалить фильтр (с помощью `pop`, `splice`, или `shift`), добавить фильтр (с помощью `push`, `splice`, `unshift`) или даже соединить несколько фильтров.

Когда вызывается `applyFilters`, все фильтры в массиве применяются к картинке **по очереди**. Вот, например, давайте создадим картинку с увеличенной яркостью и с эффектом сепии:

{% highlight javascript %}
fabric.Image.fromURL( 'pug.jpg', function ( img ) {

  img.filters.push(
    new fabric.Image.filters.Sepia(),
    new fabric.Image.filters.Brightness({ brightness: 100 }));

  img.applyFilters(canvas.renderAll.bind( canvas ));
  
  canvas.add( img );

});
{% endhighlight %}

![Fabric Image]({{site.url}}/images/uploads/2016/06/fabricjs-part-2-03.png "Fabric Image")

Заметьте, что мы передали `{ brightness: 100 }`-объект в Brightness-фильтр. Это потому, что некоторым фильтрам ничего дополнительного не нужно; а некоторым (например - `grayscale`, `invert`, `sepia`) надо указать определенные **параметры**.

Для фильтра яркости это собственно само значение яркости (`0-255`). У фильтра шума, это значение шума (`0-1000`). А у фильтра удаления белого фона ('remove white') есть порог ('threshold') и расстояние ('distance').

Ну вот разобрались с фильтрами; пора создать свой!

Образец для создания фильтров будет довольно прост. Нам нужно создать 'класс'' и написать метод `applyTo`. Опционально мы можем дать фильтру `toJSON`-метод (поддержка JSON-сериализации) и/или `initialize` (если фильтр имеет дополнительные параметры):

{% highlight javascript %}
fabric.Image.filters.Redify = fabric.util.createClass({

  type: 'Redify',

  applyTo: function ( canvasEl ) {
    var context = canvasEl.getContext( '2d' ),
        imageData = context.getImageData( 0, 0, canvasEl.width, canvasEl.height ),
        data = imageData.data;

    for ( var i = 0, len = data.length; i < len; i += 4 ) {
      data[ i + 1 ] = 0;
      data[ i + 2 ] = 0;
    }

    context.putImageData( imageData, 0, 0 );
  }
});

fabric.Image.filters.Redify.fromObject = function ( object ) {
  return new fabric.Image.filters.Redify( object );
};
{% endhighlight %}

![Fabric Image]({{site.url}}/images/uploads/2016/06/fabricjs-part-2-04.png "Fabric Image")

Не вникая сильно в подробности кода, стоит заметить, что самое главное происходит в цикле, где мы меняем зеленую (`data[i+1]`) и голубую (`data[i+2]`) компоненты каждого пикселя на `0`, по сути дела удаляя их.

Красная компонента остается нетронутой, что и делает все изображение красным.

**Примечание чтеца**: для желающих - более подробно аналог представленного выше кода описан в моей статье [Canvas - Raw Pixel][3].

Как видите, `applyTo`-метод получает в себя canvas-элемент, который представляет собой изображение. Имея такой canvas, мы можем пройтись по всем пикселям изображения (`getImageData().data`) изменяя их как нам угодно.

## Цвета

Независимо от того, с чем вам удобней работать — hex, RGB, или RGBA-форматами цвета — Fabric упрощает утомительные операции и **переводы из одного формата в другой**.

Давайте посмотрим на несколько способов **определить цвет** в Fabric:

{% highlight javascript %}
new fabric.Color( '#f55' );
new fabric.Color( '#123123' );
new fabric.Color( '356735' );
new fabric.Color( 'rgb( 100, 0, 100 )' );
new fabric.Color( 'rgba( 10, 20, 30, 0.5 )' );
{% endhighlight %}

**Перевод формата** происходит очень просто. Метод `toHex()` переводит цвет в `hex`. Метод `toRgb()` — в `RGB`, а метод `toRgba()` — в `RGB` с альфа каналом (прозрачностью):

{% highlight javascript %}
new fabric.Color( '#f55' ).toRgb(); // => "rgb( 255, 85, 85 )"
new fabric.Color( 'rgb( 100, 100, 100 )' ).toHex(); // => "646464"
new fabric.Color( 'fff' ).toHex(); // => "FFFFFF"
{% endhighlight %}

Кстати, можно делать не только перевод. Можно "накладывать" цвета один на другой или делать из них черно-белый вариант:

{% highlight javascript %}
var redish = new fabric.Color('#f55');
var greenish = new fabric.Color('#5f5');

redish.overlayWith(greenish).toHex(); // => "AAAA55"
redish.toGrayscale().toHex(); // => "A1A1A1"
{% endhighlight %}



----------------------------------------------------------------------------------------------------------------------------

// FILE NAME
// year-month-day-name
2013-01-15-archlinux-slim.md

// CODE SNIPPET
{% highlight javascript %}
// ...
{% endhighlight %}

// INLINE LINK
[link]( "link title")

// ANNOUNCEED LINK
[text][1]

// INLINE IMAGE
![image title]({{site.url}}/images/uploads/2015/08/image.jpg "image alt") 

***
[1]: http://gearmobile.github.io/javascript/fabric-part-01/ "Знакомимся с Fabric.js - Часть 1"
[2]: http://fabricjs.com/fabric-intro-part-2_ru "Знакомимся с Fabric.js. Часть 2-я."
[3]: http://gearmobile.github.io/javascript/canvas-raw-pixel/ "Canvas - Raw Pixel"
