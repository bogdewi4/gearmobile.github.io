---
title: "Модульная система Node.js"
layout: post
categories: javascript
tags: [javascript, nodejs]
share: true
---

Что такое модульная система в Node.js и как ею пользоваться. Сразу скажу - материал не мой и я вообще редко делаю копипаст.

Но эта статья мне очень понравилась - в ней автор подробно и внятно доносит тему. Кроме того, это тот самый случай, когда я наконец нашел ответ на свой вопрос.

Итак - первоисточник находится здесь - [Руководство для начинающих по Node.js от Felix’a][1]. Дальше - текст статьи.

***

Для организации программ в виде отдельных файлов Node.js предлагает к использованию **модульную систему**.

Для демонстрации подхода создадим файл `main.js` со следующим содержимым:

{% highlight javascript %}
var hello = require('./hello');
hello.world();
{% endhighlight %}

Нетрудно догадаться, что функция `require('./hello')` используется для **импорта данных** из отдельного JavaScript-файла.

`./` - означает, что файл находится в той же директории, что и сам файл `main.js`. Также следует обратить внимание на то, что **не требуется указывать расширение** файла, так как `.js` подставляется по умолчанию.

Далее необходимо создать файл (модуль) `hello.js` со следующим содержимым:

{% highlight javascript %}
exports.world = function () {
  console.log('Hello World');
}
{% endhighlight %}

Тут следует обратить внимание на то, что происходит **присваивание** свойству `world` объекта `exports`.

Таким образом объявляется, что модуль `hello.js` **экспортирует** во вне функцию `world`.

Объект `exports` доступен в любом модуле и возвращается при каждом вызове функции `require` при подключении модуля.

При запуске `main.js` вывод будет следующим:

{% highlight javascript %}
$ node main.js
Hello World
{% endhighlight %}

Будет не лишним упомянуть, что зачастую объект `exports` переопределяется следующим образом:

{% highlight javascript %}
module.exports = function () {
  // ...
}
{% endhighlight %}

Как и ожидается, такое переопределение будет причиной того, что `require` будет возвращать функцию.

Такой подход полезен при объекто-ориентированном программировании (ООП), где каждый файл экспортирует конструктор одного класса.

Следующая вещь, которую надо понимать при работе с модульной системой, это то, как система работает с вызовами `require`, которые **не включают** относительную подсказку о местоположении подключаемого файла.

Например:

{% highlight javascript %}
var http = require('http');
{% endhighlight %}

Первое, что сделает Node.js - это определит, есть ли модуль ядра с именем `http`. Если есть, то вернет соответствующую директорию.

Но что будет при работе с модулями, не относящимися к ядру, как, например, `mysql`?

{% highlight javascript %}
var mysql = require('mysql');
{% endhighlight %}

В этом случае Node.js будет искать модуль в каждой директории, начиная с одного из текущих файлов, и проверять есть ли директория с именем `node_modules`. Если такая директория найдена, Node.js начнет поиск в ней файла с именем `mysql.js`.

Если подходящих файлов не найдено и достигнут корень файловой системы (`/`), Node.js сдается и выбрасывает исключение.

В настоящий момент Node.js учитывает дополнительный изменяемый **список альтернативных директорий для импорта**. Список доступен через массив `require.paths`. Однако идет активное обсуждение на тему удаления этой возможности, так что лучше пока не использовать ее.

И наконец, Node.js учитывает файл `index.js`, в котором описывается главный файл импорта для директории.

Таким образом, если встретится вызов `require('./foo')`, то Node.js будет пробовать искать файлы и `foo.js` и `foo/index.js`.

JavaScript-flood продолжается ... )

***
[1]: http://nodeguide.ru/doc/felix/beginner/ "Руководство для начинающих по Node.js от Felix'a"
